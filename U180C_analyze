#!/usr/bin/env python

import pandas as pd
from matplotlib import pyplot as plt
from IPython import embed
import numpy as np
#import seaborn as sns
#sns.set(palette="Set2")


msg = """

A short HowTo for U180C_analyze
-------------------------------

The values are read into a **[Pandas DataFrame][]** stored in the variable **`df`**.

[Pandas Dataframe]: http://pandas.pydata.org/pandas-docs/dev/generated/pandas.DataFrame.html

Now, you can **plot measures** like this:

    df.loc[:,['S1', 'Q1']].plot()
    plt.show()

To get a **list of all available measures**, type:

    " ".join(df.columns)

You can also **do calculations** with individual columns.
Here, the absolute value of Q1 is written to the column abs_Q1:

    df['abs_Q1'] = df.Q1.abs()

If you want to **thin out** (= resample) the dataframe, you can do it like this:

    dfr = df.resample("5min", how='mean')
    # how can be: min max median mean

To calculate a **rolling average** with a window comprising 60 rows
(equivalent to 5 minutes if 5 seconds is the sampling period).

    pd.rolling_mean(df.P1, 60)

Calculating an **exponentially weighted moving average** is also easy:

    pd.ewma(df.P1, span=20)

A nice plot - the actual power averaged over five minutes wrapped in its **min/max band**:

    dfr = df.loc[:,['P1', 'S1', 'Q1']].resample("5min", how=['min', 'max', 'mean'])
    plt.plot(dfr.index, dfr.P1['mean'])
    plt.fill_between(dfr.index, dfr.P1['min'],dfr.P1['max'],facecolor='b',alpha=0.5)
    plt.show()

How about an **area plot for the actual power** (after resampling to 5mins)
(the plot is stacked automatically).

    df.resample("5min", how='mean').loc[:, ['P3', 'P1', 'P2']].plot(kind='area')

Another way to look at the data is to check for changes in the power consumption.
To do so, you can draw a **histogram for the absolute differences of the actual power from one measurement to the next**.
This should allow to identify consumers with fixed power consumption at switching time:

    df['P1'].diff().abs().hist(histtype='stepfilled', linewidth=0, range=(1,1000), bins=999, log=True)
    # or check the difference between every second measurement:
    df[::2]['P1'].diff().abs().hist(histtype='stepfilled', linewidth=0, range=(1,1000), bins=999, log=True)
    plt.show()

Also an important task is the calculation of the **energy consumed per day**:

    dfr = df.loc[:,['kWh1_imp','kWh2_imp', 'kWh3_imp']].resample("D", how=['min', 'max'])
    dfr /= 1000.
    dfr['L1'] = dfr['kWh1_imp']['max'] - dfr['kWh1_imp']['min']
    dfr['L2'] = dfr['kWh2_imp']['max'] - dfr['kWh2_imp']['min']
    dfr['L3'] = dfr['kWh3_imp']['max'] - dfr['kWh3_imp']['min']
    dfr.columns = dfr.columns.droplevel(level=1)
    dfr = dfr.loc[:, ['L1', 'L2', 'L3']]
    dfr['all'] = dfr.L1 + dfr.L2 + dfr.L3
    ax = dfr.plot(title='energy used per day', lw=2,colormap='jet',marker='.',markersize=10)
    ax.set_ylabel("kWh")
    plt.show()

-----------------------------

"""

def main():
    import argparse

    parser = argparse.ArgumentParser(description='Analysis software for a U189A energy counter with U180C LAN interface.')
    parser.add_argument('input_file', help='The data file to read')

    args = parser.parse_args()

    df = pd.io.parsers.read_csv(args.input_file, sep=';', parse_dates=[['Date', 'Time']], dayfirst=True)
    df.set_index('Date_Time', inplace = True)
    if 'SN' in df.columns: df.drop('SN', axis=1, inplace = True)
    print("Finished reading the data file in.")

    print(msg)
    try:
        import webbrowser
        import tempfile
        import markdown
        fp = tempfile.NamedTemporaryFile(mode='w', suffix='.html', delete=False)
        filename = fp.name
        with fp:
            fp.write(markdown.markdown(msg))
            fp.close()
        webbrowser.open_new_tab('file://' + filename)
    except Exception as e:
        print(str(e))

    embed()

if __name__ == "__main__":
    main()
